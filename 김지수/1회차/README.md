## 개요
1. 일자 : 2018. 12. 15 (토) 14:00 ~ 17:30
2. 장소 : 강남역 363 바이 아이디어 그룹

## 수업내용
#### C 프로그래밍 기본 개념
1. C의 역사

C의 역사는 1960년 경에 만들어진 CPL(Combined Programming Language)로부터 시작된다. CPL 언어는 ALGOL60을 개량하여 만들어진 것이다. 이후 1967년 경 마틴 리챠즈(Martin Richards)가 CPL을 수정하여 BCPL(Basic CPL)이라는 언어를 만들었다. 이 언어는 주로 컴파일러와 같은 시스팀 소프트웨어를 작성할 목적으로 설계된 것이다. BCPL은 현재까지도 주로 유럽에서 사용되고 있다.

앞에서 유닉스를 얘기할 때 언급했지만 최초의 유닉스 시스팀은 PDP-7 어셈블리어로 쓰여졌다. 뒤에 초기 유닉스의 플랫폼이 PDP-7에서 1970년 말에 PDP-11으로 바뀌었지만 그 시스팀 커널과 유틸러티들은 여전히 어셈블리어로 쓰여 있었다. 이러한 상황에 부분적인 변화가 있었던 것은 1972년 7월에 나온 유닉스 제2판이었다. 여기서도 커널과 많은 유틸러티들은 어셈블리어로 작성되었지만 어셈블러 자체는 B 언어로 쓰여진 것이었다. B 언어는 켄 탐슨이 BCPL을 수정하여 1970년에 만든 언어이다. (그 이름은 단순히 BCPL을 간단히 줄여 만든 것이다.)

BCPL과 B는 모두 형이 '없는(typeless)' 언어였다. 이들 언어에서 제공하는 유일한 자료형은 기계 워드(machine word)였고 다른 종류의 자료를 사용하기 위해서는 특별한 연산자나 함수 호출을 사용해야 했다. 이런 제약으로 인해 PDP-11에 있는 바이트 조작 명령어를 자유롭게 사용하기가 어려웠다. 그래서 B 언어에 형을 추가시키는 작업이 이루어져 새로운 언어 NB(New B)가 만들어졌다. 이 NB를 사용하여 시스팀 소프트웨어를 새로 작성하려는 시도가 있었지만 결과가 별로 좋지 않아서 데니스 리치는 컴파일한 프로그램이 빨리 수행될 수 있도록 하기 위하여 NB를 위한 코드 생성기(generator)를 연구하면서 동시에 효율적인 코드 생성을 위한 언어를 구상했다. 이 결과로 탄생한 것이 C 언어이다. (그 이름은 B 다음에 만들어 졌다고 붙인 것이다. 벨 연구소의 빼어난 프로그래머들은 작명에는 별로 관심이 없는 것 같다...) 이 최초의 C 언어에는 오늘날의 C가 가지고 있는 스트럭쳐(structure)나 전역 변수(global variable) 등의 기능이 없었다.


2. C의 강점

C가 오늘날처럼 광범위하게 사용되는 데는 C 언어 자체의 이유와 외부적인 이유가 공존한다. 먼저 외부적인 이유로는 유닉스의 성공을 들 수 있다. `유닉스 시스팀의 구현 언어로서 사용된 C는`, 유닉스 소스 프로그램의 공개로 활성화된 대학이나 기업의 연구 과정에서 자연스럽게 수많은 사람들이 C로 쓰여진 프로그램을 읽고 분석하고 수정하게 만들었다.

그러나 C 언어 자체도 성공을 가능하게 하는 요소를 (당연히!) 갖고 있다. C의 장점을 한마디로 얘기하자면 C는 프로그래머를 위한 언어'라는 것이다. 이러한 표현은 독자에게 이상하게 들릴지 모른다. 아니, 프로그래밍 언어라는 것이 그럼 프로그래머를 위한 것이지 정치가를 위한 거야? 웬 당연한 소리!''라고. 좀 더 정확하게 표현하자면 `C는 실제로 한줄 한줄 프로그램을 작성하는 전문 프로그래머의 편의를 위한 것이지 프로그래밍 언어나 소프트웨어 공학을 이론적으로 연구하는 사람 혹은 처음 프로그래밍 교육을 받는 초보자를 위한 언어가 아니라는 것이다.`

다른 고급 프로그래밍 언어와는 달리 `C는 프로그래머가 그 언어를 사용하는 데 있어서 거의 제한이 없다`. 형식적인 분류에서는 고급 언어로 구분되지만 C에는 하드웨어를 직접 효과적으로 제어할 수 있는 기능이 충분히 구비되어 있어, 시스팀 소프트웨어를 만드는 경우에도 정말 어셈블리어로 작성할 필요가 절실한 드문 상황이 아니라면 C만으로도 충분한 경우가 대부분이다. 벨 연구소에 따르면 초기 유닉스의 시스팀 전체 코드가 C 언어로 13,000줄이었는데 그중 단지 800줄만이 어셈블리어였다고 한다. 그래서 C는 기능면에서는 일반 고급 언어와 어셈블리어의 간격을 메꾸는 중간적인 성격을 갖고 있으며 따라서 포터블 어셈블리어로 불리기도 한다. (어셈블리어적인 기능을 하면서도 C 컴파일러만 구비되어 있으면 상이한 하드웨어로 이식이 용이하다는 뜻이다.)

또 `C는 자료형이 강하게 정의되어 있는(strongly-typed) 언어가 아니라는 면에서도 프로그래머에게 제한이 없다고 말할 수 있다.` PL/I처럼 마구잡이로 서로 형이 다른 자료들이 변환되는 것은 아니지만 Pascal이나 ALGOL68 혹은 Ada처럼 형의 검사가 엄격하지는 않다. 물론 이러한 측면은 프로그래밍 언어나 소프트웨어 공학의 이론적인 학자 입장에서 보면 큰 문제이고, 부주의하게 사용된다면 신뢰성있는 프로그램을 작성하는데 있어서 부정적인 요소로 작용할 수 있는 것임은 분명하다. 그래서 C가 프로그래머를 위한 언어라고 말할 때 그 프로그래머는 '전문 프로그래머'를 말한다고 해야 할 것이다. (유닉스에서는 이러한 측면을 고려하여 강한 형 검사를 수행하는 lint라는 컴파일링 프로그램을 제공하고 있다.)

이론적인 측면에서는 문제의 소지가 많으나 단지 전문 프로그래머의 작업 편의를 위한 `C 언어의 특징으로는 이외에도 goto 사용의 허용(물론 이것은 거의 모든 고급 언어들도 권장하지는 않지만 허용하니까 C 고유의 특징이라고 말할 수는 없다), 포인터(pointer)의 많은 사용, 앞에서 언급한 것과 관련하여 자동적인 형 변환(type conversion)`, 같은 의미를 표현하는데 있어서 여러가지 다른 표현이 가능한 점, 지나치게(!) 간결한 축약된 문장을 쓸 수 있게 하는 점, 형 선언이 간략하기는 하지만 반면에 알아보기가 극히 어려운 점 등을 들 수 있다. `이 모든 것들이 C 언어의 강점을 이루는 요소들이면서 동시에 개발 경험이 적은 일반 사용자들에게는 부담으로 작용한다.`


3. 해커와 C

앞 절에서 얘기한 C 언어의 특징에 의해 C를 규정하면 전형적인 '해커(hacker)를 위한 언어'라고 말할 수 있다. 여기서 말하는 해커란 보통 매스컴에서 다루는 나쁜 뜻에서의 해커가 아니라 컴퓨터에 대해 잘 알고, 프로그래밍을 즐기고 또 기가 막히게 잘 하며, 그래서 자기가 만든 재미있는 프로그램에 스스로 기뻐하고 즐거워하는 조금은 순수한 (프로 혹은 아마츄어의) 프로그래머를 말한다.

그래서 C 언어의 이러한 점을 반영한, 전세계의 C 프로그래머들을 대상으로 한 프로그램 경진 대회가 있다. 대회의 이름이 재미있는데 원명은 IOCCC(The International Obfuscated C Code Contest)이다. 우리말로 번역하면 '국제 혼돈 C 프로그램 경진 대회' 쯤 될까? 1984년부터 매년 개최되고 있는데 피라미드(Pyramid) 컴퓨터사의 랜던 커트 놀(Landon Curt Noll)과 선 마이크로시스팀즈(Sun Microsystems)사의 래리 배썰(Larry Bassel)이 창설하여 시작된 대회이다. 이름이 암시하다시피 이 대회에 제출되는 프로그램들은 가독성(readability)이 높은 학교에서 배우는 '좋은 프로그램'과는 거리가 먼, 무척 읽기는 어렵지만 대신 많은 일들을 C 문장 하나로 처리하는 것이라든지, 간단히 처리할 수 있는 일을 어렵게 해내게 프로그램을 짜서 뭘 하는 프로그램인지 모르게 하는 등의 기기묘묘한 것들로 가득하다.

C가 아닌 다른 언어로 이러한 대회가 성립될 수 있을 지는 극히 의문스럽다. 참고로 아래에 1990년도 대회에서 '최고의 짧은 프로그램(Best Small Program)' 상을 받은 바루치 니쎈바움(Baruch Nissenbaum)의 프로그램이 있다. 이 프로그램은 C 문장 하나로 구성되어 있고 하는 일은 유명한 N-queen 문제를 푸는 것이다. (인쇄의 편의를 위해서 한줄인 for 문장 하나를 여러 줄로 쪼개었다.) 아래 프로그램을 컴파일한 뒤 다음과 같이 수행시키면 입력값 크기의 서양 장기판에서의 N-queen 문제의 해가 화면에 나타날 것이다.

<pre><code>
% echo 4 | a.out

v,i,j,k,l,s,a[99];
main()
{
    for(scanf("%d",&s);*a-s;v=a[j*=v]-a[i],k=i=s*k&&++a[--i]);
}
</code></pre>

4. C, C++ 같은 언어인가요?

 C는 절차지향 언어이고, C++은 다중패러다임 언어이다. 이 한마디로 모든 설명이 끝나지만, 사족을 덧 붙이자면 절차지향언어인 C는 전체 프로세스에서 진행되는 순서에 촛점을 맞추고있다는 점과 다중패러다임 언어인 C++은 각 모듈들의 개별 기능 수행에 촛점을 맞추고 있다. 이것은 두 언어가 개발 방법론적으로 전혀 다르다고 보이며 일반적으로 개발방법론이 다른 언어는 같은 언어라고 하진 않는다. 이러한 근거를 토대로 C와 C++을 동일시하는 말을 부정할 수 있다. (C++은 C의 superset일 뿐이다.)

 * 결정적으로 C와 C++은 창시자가 다르ㄷ..

#### 포인터와 배열
1. 포인터란 무엇인가

 데이터를 저장하는 장소(object)의 번지수를 가르키고 그 곳의 데이터를 연산 할 수 있는 수단이며, 간단히 하나의 object의 주소를 저장 하는 object 라고 정의 할 수 있다. 코드를 보는게 가장 이해가 빠를거라 생각한다.

<pre>
<code>
#include <stdio.h>
 
void swap(int x, int y);
void ptrSwap(int* x, int* y);
 
int main(void) {
    int x, y;
 
    x = 10; y = 15;
 
    printf("swap 변경전 : %d %d \n", x, y);
 
    swap(x, y);
    printf("swap 변경후 : %d %d \n", x, y);
 
    ptrSwap(&x, &y);
    printf("ptrSwap 변경후 : %d %d\n", x, y);
 
    return 0;
}
 
void swap(int x, int y){
    int tmp;
    tmp = x;
    x = y;
    y = tmp;
}
 
void ptrSwap(int* x, int* y){
    int tmp;
    tmp = *x;
    *x = *y;
    *y = tmp;
}
</code>
</pre>

2. 메모리구조

 프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 로드(load)되어야 한다. 또한, 프로그램에서 사용되는 변수들을 저장할 메모리도 필요.

 따라서 컴퓨터의 운영체제는 프로그램의 실행을 위해 다양한 메모리 공간을 제공하고 있다. 프로그램이 운영체제로부터 할당받는 대표적인 메모리 공간은 다음과 같다.
 
![메모리](http://tcpschool.com/lectures/img_c_memory_structure.png)


1) 텍스트 영역
- 작성한 코드가 기계어로 변환되는 영역, EIP는 해당 코드의 흐름을 읽는 레지스트리.
- 가장 낮은 주소


2) 데이터 영역
- 초기화 된 전역, 정적 변수가 저장되는 공간.
- bss영역과 하나로 보는 경우가 많음.
- 텍스트 영역보다 높은 주소


3) bss영역
- 초기화 되지 않은 전역, 정적변수가 저장되는 공간.
- 데이터 영역과 하나로 보는 경우가 많음
- 데이터 영역보다 높은 주소


4) 힙 && 스택
- 힙 : 자유영역으로서 주소가 점점 커짐, 동적으로 할당된 메모리가 저장되는 공간
- 스택 : 예외적으로 높은영역에서 낮은영역으로 주소가 할당되는 공간, 지역변수가 저장됨.

3. 포인터와 배열 상관관계
<pre>
<code>
#include <stdio.h>
 
int getlength(char * parr){
    int length = 0;
 
    while (*parr++)
        length++;
 
    return length;
}
 
int main(void) {
 
    char arr[] = "abdsaf";
    printf("%d", getlength(arr));
 
    return 0;
}
</code>
</pre>

4. 동적할당

<pre>
<code>
#include <stdio.h>
#include <stdlib.h>
 
void create(int * _malloc){
    int* pa = _malloc;
    int i = 0;
    for (i = 0; i < 5; i++){
        pa[i] = i;
        printf("%d ", *(pa + i));
    }
    free(pa);
}
 
int main(void) {
    create( (int *)malloc(sizeof(int) * 5) );
 
 
    return 0;
}
</code>
</pre>


#### 자료구조
1. 리스트

 List란 자료의 나열인데, ArrayList와 LinkedList로 구분되어진다. 배열리스트의(ArrayList) 경우 데이터 선언시에 크기와 타입을 알아야한다는 단점이 있으나 구현 하기가 쉽다. 연결리스트의(LinkedList) 경우는 구현이 비교적 어렵지만 데이터의 동적할당이 가능해지므로서 프로그램이 구동되면서 불필요하게 메모리를 많이 잡아놔야하는 단점이 해소된다. 

 연결리스트의 구성은 값을 저장하는 Data 부분과 다음 노드의 위치인 Next* 부분으로 구성된다.

![텍스트](https://postfiles.pstatic.net/20150120_41/kikiki0611_1421758105322zySMd_JPEG/%C4%B8%C3%B3.JPG?type=w2)

2. 스택

후입선출 ( LIFO : Last In  First Out) 라고 불리우며 말 그대로 늦게 들어온 데이터가 먼저 나가는 자료구조이다.

![텍스트](https://postfiles.pstatic.net/20150120_95/kikiki0611_1421763433248SH4Ey_JPEG/1.JPG?type=w2)
![텍스트](https://postfiles.pstatic.net/20150120_65/kikiki0611_14217634416641iRh0_JPEG/2.JPG?type=w2)

3. 큐

 선입선출 ( FIFO : First In First Out) 라고 불리우며 먼저 입력한 데이터가 먼저 삭제 되는 개념이다. 아래 사진과 같은 느낌으로 이해하면 된다.

![텍스트](https://postfiles.pstatic.net/20150121_105/kikiki0611_1421842168125vpMOr_JPEG/er.JPG?type=w2)

 위와같은 사진을 을 도식화하면 아래와같다.
![텍스트](https://postfiles.pstatic.net/20150121_188/kikiki0611_1421842214803CWyYp_JPEG/%C4%B8%C3%B3.JPG?type=w2)

 리스트의 첫 위치를 Front로 나타내고 후미를 Rear로 나타내어 값이 추가 될때마다 Rear을 늘리고 삭제 될 때 Rear을 줄이는 방식이다.



#### Refereces
1. C의 역사 http://cs.sungshin.ac.kr/~dkim/UNIX-C.html
2. 다중패러다임언어 https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%A4%91_%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4
3. TCP 스쿨 http://tcpschool.com/c/c_memory_stackframe
4. 작성자 블로그 https://blog.naver.com/kikiki0611
